** step02 -> step03의 변경사항
1. Audience가 의존하는 Bag도 자율적인 존재로 변경한다.
    Audience가 가방을 뒤져서 초대장이 있는지 확인하는게 아니라, "초대장을 확인해" 라는 메시지를 보낸다.
    "초대장을 확인해" 라는 메시지를 수신할 객체는 Bag라는 객체가 되고, hold 라는 메서드로 응답한다.

    Bag 클래스의 hasInvitation, minusAmount, setTicket 메서드들의 가시성을 "private"으로 변경했다.

2. TicketOffice도 자율적인 존재로 변경했다.
    TicketOffice도 현재 TickSeller에 자율권을 침해당하고있었다.
    TicketSeller가 TickeOffice에 Ticket을 마음대로 꺼내서 자기 멋대로 Audience에게 팔고, 돈을 TicketOffice에 넣고 있었다.
    TickeSeller는 "티켓을 판매해" 라는 메시지를 송신하는 것으로 변경한다.
    "티켓을 판매해" 라는 메시지를 송신할 객체를 찾아보면 TicketOffice가 되고,
    TicketOffice는 sellTicketTo라는 메서드를 통해서 "티켓을 판매해" 라는 메시지에 응답하게 된다.


=>
TicketSeller가 TicketOffice의 구현이 아닌 인터페이스에 의존하게 되었다는 점이 있지만, ticketOffice가 Audience와의 의존관계가 추가되었다.
TicketOffice의 자율성은 높였지만, 전체 설계에서 관점에서의 결합도는 상승했다.
자율성을 높일 것인가 결합도를 낮출 것인가.. => 트레이드 오프 시점이고, 설계는 트레이드 오프가 반복된 결과이다.
이 책에서는 전체적인 결합도와 객체의 자율성 중 결합도를 선택했다고 한다.

이 예제를 통해서 여러분은 두가지 사실을 알게 됐다.
    1. 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
    2. 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드 오프의 산물이다.


좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.